!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
$GET_MAX_DEPTH	tree.cpp	/^#define $GET_MAX_DEPTH /;"	d	file:
$GET_ROOT	tree.cpp	/^#define $GET_ROOT /;"	d	file:
$GET_VALUE	tree.cpp	/^#define $GET_VALUE /;"	d	file:
$INSERT_METHOD	tree.cpp	/^#define $INSERT_METHOD(/;"	d	file:
$KEY	main.cpp	/^#define $KEY /;"	d	file:
$NODE_TYPE	tree.cpp	/^#define $NODE_TYPE /;"	d	file:
$OP_CONTEXT	BST_iterator.bak.hpp	/^# undef $OP_CONTEXT$/;"	d
$OP_CONTEXT	BST_iterator.bak.hpp	/^#define $OP_CONTEXT /;"	d
$OP_CONTEXT	BST_iterator.hpp	/^# undef $OP_CONTEXT$/;"	d
$OP_CONTEXT	BST_iterator.hpp	/^#define $OP_CONTEXT /;"	d
$OP_CONTEXT	BST_iterator.orig.hpp	/^# undef $OP_CONTEXT$/;"	d
$OP_CONTEXT	BST_iterator.orig.hpp	/^#define $OP_CONTEXT /;"	d
$OP_CONTEXT	BST_iterator_rev.hpp	/^# undef $OP_CONTEXT$/;"	d
$OP_CONTEXT	BST_iterator_rev.hpp	/^#define $OP_CONTEXT /;"	d
$OP_CONTEXT	ft_pair.hpp	/^	# define $OP_CONTEXT /;"	d
$OP_CONTEXT	ft_pair.hpp	/^	# undef $OP_CONTEXT$/;"	d
$OP_CONTEXT	random_access_iterator.hpp	/^	# define $OP_CONTEXT /;"	d
$OP_CONTEXT	random_access_iterator.hpp	/^	# undef $OP_CONTEXT$/;"	d
$OP_CONTEXT	random_access_iterator_rev.hpp	/^	# define $OP_CONTEXT /;"	d
$OP_CONTEXT	random_access_iterator_rev.hpp	/^	# undef $OP_CONTEXT$/;"	d
$OP_CONTEXT	stack.hpp	/^	# define $OP_CONTEXT /;"	d
$OP_CONTEXT	stack.hpp	/^	# undef $OP_CONTEXT$/;"	d
$OP_CONTEXT	vector.hpp	/^	# define $OP_CONTEXT /;"	d
$OP_CONTEXT	vector.hpp	/^	# undef $OP_CONTEXT$/;"	d
$OP_CONTEXT_PARAM	ft_pair.hpp	/^	# define $OP_CONTEXT_PARAM /;"	d
$OP_CONTEXT_PARAM	ft_pair.hpp	/^	# undef $OP_CONTEXT_PARAM$/;"	d
$OP_CONTEXT_PARAM	random_access_iterator.hpp	/^	# define $OP_CONTEXT_PARAM /;"	d
$OP_CONTEXT_PARAM	random_access_iterator.hpp	/^	# undef $OP_CONTEXT_PARAM$/;"	d
$OP_CONTEXT_PARAM	random_access_iterator_rev.hpp	/^	# define $OP_CONTEXT_PARAM /;"	d
$OP_CONTEXT_PARAM	random_access_iterator_rev.hpp	/^	# undef $OP_CONTEXT_PARAM$/;"	d
$OP_CONTEXT_PARAM	stack.hpp	/^	# define $OP_CONTEXT_PARAM /;"	d
$OP_CONTEXT_PARAM	stack.hpp	/^	# undef $OP_CONTEXT_PARAM$/;"	d
$OP_CONTEXT_PARAM	vector.hpp	/^	# define $OP_CONTEXT_PARAM /;"	d
$OP_CONTEXT_PARAM	vector.hpp	/^	# undef $OP_CONTEXT_PARAM$/;"	d
$OP_PARAM_CONTEXT	BST_iterator.bak.hpp	/^# undef $OP_PARAM_CONTEXT$/;"	d
$OP_PARAM_CONTEXT	BST_iterator.bak.hpp	/^#define $OP_PARAM_CONTEXT /;"	d
$OP_PARAM_CONTEXT	BST_iterator.hpp	/^# undef $OP_PARAM_CONTEXT$/;"	d
$OP_PARAM_CONTEXT	BST_iterator.hpp	/^#define $OP_PARAM_CONTEXT /;"	d
$OP_PARAM_CONTEXT	BST_iterator.orig.hpp	/^# undef $OP_PARAM_CONTEXT$/;"	d
$OP_PARAM_CONTEXT	BST_iterator.orig.hpp	/^#define $OP_PARAM_CONTEXT /;"	d
$OP_PARAM_CONTEXT	BST_iterator_rev.hpp	/^# undef $OP_PARAM_CONTEXT$/;"	d
$OP_PARAM_CONTEXT	BST_iterator_rev.hpp	/^#define $OP_PARAM_CONTEXT /;"	d
$T	main.cpp	/^#define $T /;"	d	file:
$TREE_TYPE	tree.cpp	/^#define $TREE_TYPE /;"	d	file:
$WHAT_TO_INSERT	tree.cpp	/^#define $WHAT_TO_INSERT(/;"	d	file:
$clear_erase	vector.hpp	/^	#define $clear_erase /;"	d
$enable_if_arithmetic	vector.hpp	/^	#define $enable_if_arithmetic	/;"	d
$getRange	vector.hpp	/^	#define $getRange(/;"	d
$mem_erase	BST_MAP.hpp	/^	#define $mem_erase(/;"	d
$mem_erase	vector.hpp	/^	#define $mem_erase(/;"	d
$mem_free	BST_MAP.hpp	/^	#define $mem_free(/;"	d
$mem_free	vector.hpp	/^	#define $mem_free(/;"	d
$mem_get	BST_MAP.hpp	/^	#define $mem_get(/;"	d
$mem_get	vector.hpp	/^	#define $mem_get(/;"	d
$mem_put	BST_MAP.hpp	/^	#define $mem_put(/;"	d
$mem_put	vector.hpp	/^	#define $mem_put(/;"	d
A	main.cpp	/^#define A(/;"	d	file:
ADD_USAGE	tree.cpp	/^#define ADD_USAGE /;"	d	file:
BST	BST.cpp	/^	BST() : root(NULL) , _pair_allocator(NULL), size(0) {}$/;"	f	class:BST	file:
BST	BST.cpp	/^	BST(std::allocator<ft::pair<const Key, T2>>* $allocator) : root(NULL) , size(0)$/;"	f	class:BST	file:
BST	BST.cpp	/^class BST$/;"	c	file:
BST	BST_MAP.hpp	/^	BST(const Compare& $cmp = Compare()) : root(NULL) , _size(0), cmp($cmp) {}$/;"	f	class:BST
BST	BST_MAP.hpp	/^class BST$/;"	c
BST	BST_MAP_NOCOMPARE.hpp	/^	BST() : root(NULL) , _size(0){}$/;"	f	class:BST
BST	BST_MAP_NOCOMPARE.hpp	/^class BST$/;"	c
BST	BST_old.hpp	/^	BST() : parent(NULL) , size(0) {}$/;"	f	class:BST
BST	BST_old.hpp	/^class BST$/;"	c
BST_CONF_HPP	BST.conf.hpp	/^# define BST_CONF_HPP$/;"	d
BST_HPP	BST_old.hpp	/^# define BST_HPP$/;"	d
BST_ITERATOR_HPP	BST_iterator.bak.hpp	/^# define BST_ITERATOR_HPP$/;"	d
BST_ITERATOR_HPP	BST_iterator.hpp	/^# define BST_ITERATOR_HPP$/;"	d
BST_ITERATOR_HPP	BST_iterator.orig.hpp	/^# define BST_ITERATOR_HPP$/;"	d
BST_ITERATOR_REV_HPP	BST_iterator_rev.hpp	/^# define BST_ITERATOR_REV_HPP$/;"	d
BST_MAP_HPP	BST_MAP.hpp	/^#define BST_MAP_HPP$/;"	d
BST_MAP_HPP	BST_MAP_NOCOMPARE.hpp	/^#define BST_MAP_HPP$/;"	d
BST_iterator	BST_iterator.bak.hpp	/^	BST_iterator(const BST_iterator& src) : pos(src.pos), root(src.root) {}$/;"	f	class:ft::BST_iterator
BST_iterator	BST_iterator.bak.hpp	/^	BST_iterator(ptr $root, ptr $pos) : pos($pos), root($root) {}$/;"	f	class:ft::BST_iterator
BST_iterator	BST_iterator.bak.hpp	/^	BST_iterator(void) : pos(NULL), root(NULL) {}$/;"	f	class:ft::BST_iterator
BST_iterator	BST_iterator.bak.hpp	/^class BST_iterator$/;"	c	namespace:ft
BST_iterator	BST_iterator.hpp	/^	 BST_iterator(const BST_iterator& src)$/;"	f	class:ft::BST_iterator
BST_iterator	BST_iterator.hpp	/^	 BST_iterator(ptr $root, ptr $pos, bool nil) : val(ft::make_pair($pos, nil)), root($root)$/;"	f	class:ft::BST_iterator
BST_iterator	BST_iterator.hpp	/^	BST_iterator(void) : root(NULL) { }$/;"	f	class:ft::BST_iterator
BST_iterator	BST_iterator.hpp	/^class BST_iterator$/;"	c	namespace:ft
BST_iterator	BST_iterator.orig.hpp	/^	BST_iterator(const BST_iterator& src) : pos(src.pos), root(src.root), nil(src.nil) {}$/;"	f	class:ft::BST_iterator
BST_iterator	BST_iterator.orig.hpp	/^	BST_iterator(ptr $root, ptr $pos) : pos($pos), root($root), nil(false)$/;"	f	class:ft::BST_iterator
BST_iterator	BST_iterator.orig.hpp	/^	BST_iterator(void) : pos(NULL), root(NULL), nil(false) {}$/;"	f	class:ft::BST_iterator
BST_iterator	BST_iterator.orig.hpp	/^class BST_iterator$/;"	c	namespace:ft
BST_iterator_rev	BST_iterator_rev.hpp	/^	 BST_iterator_rev(const BST_iterator_rev& src)$/;"	f	class:ft::BST_iterator_rev
BST_iterator_rev	BST_iterator_rev.hpp	/^	 BST_iterator_rev(const ft::BST_iterator<T, BST_NODE>& src) : root(src.getRoot())$/;"	f	class:ft::BST_iterator_rev
BST_iterator_rev	BST_iterator_rev.hpp	/^	 BST_iterator_rev(ptr $root, ptr $pos, bool nil) : val(ft::make_pair($pos, nil)), root($root)$/;"	f	class:ft::BST_iterator_rev
BST_iterator_rev	BST_iterator_rev.hpp	/^	BST_iterator_rev(void) : root(NULL) { }$/;"	f	class:ft::BST_iterator_rev
BST_iterator_rev	BST_iterator_rev.hpp	/^class BST_iterator_rev$/;"	c	namespace:ft
COLOR	tree.cpp	/^#define COLOR(/;"	d	file:
CYAN	tree.cpp	/^#define CYAN /;"	d	file:
ELSE_DO_NOT1HING	BST_old.hpp	/^		#define ELSE_DO_NOT1HING /;"	d
ELSE_DO_NOTHING	BST_MAP.hpp	/^		#define ELSE_DO_NOTHING /;"	d
ELSE_DO_NOTHING	BST_MAP_NOCOMPARE.hpp	/^		#define ELSE_DO_NOTHING /;"	d
ENABLE_IF_HPP	enable_if.hpp	/^	# define ENABLE_IF_HPP$/;"	d
FT_PAIR_HPP	ft_pair.hpp	/^# define FT_PAIR_HPP$/;"	d
GET	BST_MAP.hpp	/^	#define GET /;"	d
GET	BST_MAP_NOCOMPARE.hpp	/^	#define GET /;"	d
GREEN	tree.cpp	/^#define GREEN /;"	d	file:
HAS_ONE_CHILDREN	BST_MAP.hpp	/^		#define HAS_ONE_CHILDREN(/;"	d
HAS_ONE_CHILDREN	BST_MAP_NOCOMPARE.hpp	/^		#define HAS_ONE_CHILDREN(/;"	d
HAS_ONE_CHILDREN	BST_old.hpp	/^		#define HAS_ONE_CHILDREN(/;"	d
HAS_T1WO_CHILDREN	BST_old.hpp	/^		#define HAS_T1WO_CHILDREN(/;"	d
HAS_TWO_CHILDREN	BST_MAP.hpp	/^		#define HAS_TWO_CHILDREN(/;"	d
HAS_TWO_CHILDREN	BST_MAP_NOCOMPARE.hpp	/^		#define HAS_TWO_CHILDREN(/;"	d
IF_PARENT1_EXIST1S	BST_old.hpp	/^		#define IF_PARENT1_EXIST1S(/;"	d
IF_PARENT_EXISTS	BST_MAP.hpp	/^		#define IF_PARENT_EXISTS(/;"	d
IF_PARENT_EXISTS	BST_MAP_NOCOMPARE.hpp	/^		#define IF_PARENT_EXISTS(/;"	d
INFO	tree.cpp	/^#define INFO(/;"	d	file:
INSERT_AND_PRINT	main.cpp	/^#define INSERT_AND_PRINT(/;"	d	file:
IS_A_LEAF	BST_MAP.hpp	/^	#define IS_A_LEAF(/;"	d
IS_A_LEAF	BST_MAP_NOCOMPARE.hpp	/^	#define IS_A_LEAF(/;"	d
IS_A_LEAF	BST_old.hpp	/^	#define IS_A_LEAF(/;"	d
IS_FIRST_INSERT	BST_MAP.hpp	/^	#define IS_FIRST_INSERT /;"	d
IS_FIRST_INSERT	BST_MAP_NOCOMPARE.hpp	/^	#define IS_FIRST_INSERT /;"	d
IS_FIRST_INSERT	BST_old.hpp	/^	#define IS_FIRST_INSERT /;"	d
KEY	BST_MAP.hpp	/^		#define KEY(/;"	d
Key_compare	map.hpp	/^			typedef Compare								Key_compare;$/;"	t	class:ft::map
NM	main.cpp	/^#define NM /;"	d	file:
NM	main_perf_map.cpp	/^#define NM /;"	d	file:
NODE_IS_ROOT	BST_MAP.hpp	/^		#define NODE_IS_ROOT(/;"	d
NODE_IS_ROOT	BST_MAP_NOCOMPARE.hpp	/^		#define NODE_IS_ROOT(/;"	d
NODE_IS_ROOT1	BST_old.hpp	/^		#define NODE_IS_ROOT1(/;"	d
POS_LEFT_USAGE	tree.cpp	/^#define POS_LEFT_USAGE /;"	d	file:
POS_PARENT_USAGE	tree.cpp	/^#define POS_PARENT_USAGE /;"	d	file:
POS_RIGHT_USAGE	tree.cpp	/^#define POS_RIGHT_USAGE /;"	d	file:
PRINT_USAGE	tree.cpp	/^#define PRINT_USAGE /;"	d	file:
RANDOM_ACCESS_ITERATOR_HPP	random_access_iterator.hpp	/^# define RANDOM_ACCESS_ITERATOR_HPP$/;"	d
RANDOM_ACCESS_ITERATOR_REV_HPP	random_access_iterator_rev.hpp	/^# define RANDOM_ACCESS_ITERATOR_REV_HPP$/;"	d
RESET	tree.cpp	/^#define RESET /;"	d	file:
SAVE	BST_MAP.hpp	/^	#define SAVE /;"	d
SAVE	BST_MAP_NOCOMPARE.hpp	/^	#define SAVE /;"	d
SEARCH_FAILED	BST_MAP.hpp	/^	#define SEARCH_FAILED(/;"	d
SEARCH_FAILED	BST_MAP_NOCOMPARE.hpp	/^	#define SEARCH_FAILED(/;"	d
SEARCH_FAILED	BST_old.hpp	/^	#define SEARCH_FAILED(/;"	d
SEARCH_USAGE	tree.cpp	/^#define SEARCH_USAGE /;"	d	file:
STACK_HPP	stack.hpp	/^# define STACK_HPP$/;"	d
T1	main.cpp	/^#define T1 /;"	d	file:
T1	main_erase.cpp	/^#define T1 /;"	d	file:
T1	mainite.cpp	/^#define T1 /;"	d	file:
T2	main.cpp	/^#define T2 /;"	d	file:
T2	main_erase.cpp	/^#define T2 /;"	d	file:
T2	mainite.cpp	/^#define T2 /;"	d	file:
T3	main.cpp	/^typedef TESTED_NAMESPACE::pair<const T1, T2> T3;$/;"	t	file:
T3	main_erase.cpp	/^typedef TESTED_NAMESPACE::pair<const T1, T2> T3;$/;"	t	file:
T3	mainite.cpp	/^typedef TESTED_NAMESPACE::map<T1, T2>::value_type T3;$/;"	t	file:
TESTED_NAMESPACE	main.cpp	/^#define TESTED_NAMESPACE /;"	d	file:
TESTED_NAMESPACE	main_erase.cpp	/^#define TESTED_NAMESPACE /;"	d	file:
TESTED_NAMESPACE	mainite.cpp	/^#define TESTED_NAMESPACE /;"	d	file:
Trunk	main.cpp	/^    Trunk(Trunk *prev, std::string str)$/;"	f	struct:Trunk
Trunk	main.cpp	/^struct Trunk$/;"	s	file:
Trunk	tree.cpp	/^    Trunk(Trunk *prev, std::string str)$/;"	f	struct:Trunk
Trunk	tree.cpp	/^struct Trunk$/;"	s	file:
USAGE	tree.cpp	/^#define USAGE /;"	d	file:
VALUE_IS_FOUND	BST_MAP.hpp	/^	#define VALUE_IS_FOUND /;"	d
VALUE_IS_FOUND	BST_MAP_NOCOMPARE.hpp	/^	#define VALUE_IS_FOUND /;"	d
VALUE_IS_FOUND	BST_old.hpp	/^	#define VALUE_IS_FOUND /;"	d
VALUE_IS_GREAT1ER	BST_old.hpp	/^	#define VALUE_IS_GREAT1ER /;"	d
VALUE_IS_GREATER	BST_MAP.hpp	/^	#define VALUE_IS_GREATER /;"	d
VALUE_IS_GREATER	BST_MAP_NOCOMPARE.hpp	/^	#define VALUE_IS_GREATER /;"	d
VALUE_IS_LESS	BST_MAP.hpp	/^	#define VALUE_IS_LESS /;"	d
VALUE_IS_LESS	BST_MAP_NOCOMPARE.hpp	/^	#define VALUE_IS_LESS /;"	d
VALUE_IS_LESS	BST_old.hpp	/^	#define VALUE_IS_LESS /;"	d
WARNING	tree.cpp	/^#define WARNING(/;"	d	file:
YELLOW	tree.cpp	/^#define YELLOW /;"	d	file:
_Base	BST_MAP.hpp	/^		Allocator _Base;$/;"	m	class:BST
_Base	map.hpp	/^				allocator_type _Base;$/;"	m	class:ft::map
_Base	vector.hpp	/^		allocator_type	_Base;$/;"	m	class:ft::vector
__INSERT__DEFAULT__	vector.hpp	/^		bool			__INSERT__DEFAULT__;$/;"	m	class:ft::vector
_array	vector.hpp	/^		pointer			_array;$/;"	m	class:ft::vector
_capacity	vector.hpp	/^		size_type		_capacity;$/;"	m	class:ft::vector
_delete	BST_MAP.hpp	/^	void	_delete(node* d)$/;"	f	class:BST
_pair	BST.cpp	/^		ft::pair<const Key, T2> _pair;$/;"	m	class:BST::node	file:
_pair	BST_MAP.hpp	/^	ft::pair<const Key, T> _pair;$/;"	m	class:node
_pair	BST_MAP_NOCOMPARE.hpp	/^	ft::pair<const Key, T> _pair;$/;"	m	class:node
_pair_allocator	BST.cpp	/^		std::allocator<ft::pair<const Key, T2>> *_pair_allocator;$/;"	m	class:BST	file:
_size	BST_MAP.hpp	/^		size_t _size;$/;"	m	class:BST
_size	BST_MAP_NOCOMPARE.hpp	/^		size_t _size;$/;"	m	class:BST
allocator_type	map.hpp	/^			typedef Allocator							allocator_type;$/;"	t	class:ft::map
allocator_type	vector.hpp	/^    typedef Alloc 												allocator_type;$/;"	t	class:ft::vector
assign	vector.hpp	/^		void	assign(InputIterator first, InputIterator last,$/;"	f	class:ft::vector
assign	vector.hpp	/^	void	assign(size_type n, const value_type& val)$/;"	f	class:ft::vector
at	vector.hpp	/^	const_reference at(size_type n) const$/;"	f	class:ft::vector
at	vector.hpp	/^	reference at(size_type n) \/\/ same as [] but throws and exception$/;"	f	class:ft::vector
back	vector.hpp	/^	const_reference back() const 	{ return (_array[pos - 1]); } \/\/returns direct const_reference to container last elem$/;"	f	class:ft::vector
back	vector.hpp	/^	reference back()				{ return (_array[pos - 1]); } \/\/returns direct reference to container last elem$/;"	f	class:ft::vector
balanceFactor	BST_MAP.hpp	/^	int	balanceFactor(node *position)$/;"	f	class:BST
balanceFactor	BST_MAP_NOCOMPARE.hpp	/^	int	balanceFactor(node *position)$/;"	f	class:BST
balance_rm	BST_MAP.hpp	/^	node*	balance_rm(node* at)$/;"	f	class:BST
base	BST_iterator_rev.hpp	/^	BST_iterator<T, BST_NODE>	base() const$/;"	f	class:ft::BST_iterator_rev
base	random_access_iterator_rev.hpp	/^	random_access_iterator<T> base() const { return (random_access_iterator<T>(ptr + 1)); }$/;"	f	class:ft::random_access_iterator_rev
begin	BST_MAP.hpp	/^	const_iterator 	begin() const { return(iterator(root, maxL(root), false)); }$/;"	f	class:BST
begin	BST_MAP.hpp	/^	iterator 	begin() { return(iterator(root, maxL(root), false)); }$/;"	f	class:BST
begin	BST_MAP_NOCOMPARE.hpp	/^	const_iterator 	begin() const { return(iterator(root, maxL(root), false)); }$/;"	f	class:BST
begin	BST_MAP_NOCOMPARE.hpp	/^	iterator 	begin() { return(iterator(root, maxL(root), false)); }$/;"	f	class:BST
begin	map.hpp	/^			const_iterator 	begin() const { return(tree.begin()); }$/;"	f	class:ft::map
begin	map.hpp	/^			iterator 	begin() { return(tree.begin()); }$/;"	f	class:ft::map
begin	vector.hpp	/^	const_iterator	begin() const { return (iterator(_array)); }$/;"	f	class:ft::vector
begin	vector.hpp	/^	iterator	begin() { return (iterator(_array)); }$/;"	f	class:ft::vector
binary_function	map.hpp	/^  	struct binary_function {$/;"	s	namespace:ft
c	stack.hpp	/^		container_type c;$/;"	m	class:ft::stack
capacity	vector.hpp	/^	size_type	capacity() const 	{ return (_capacity); } \/\/returns container capacity$/;"	f	class:ft::vector
clear	BST_MAP.hpp	/^	void	clear()$/;"	f	class:BST
clear	map.hpp	/^			void	clear()$/;"	f	class:ft::map
clear	vector.hpp	/^	void	clear()$/;"	f	class:ft::vector
cmp	BST_MAP.hpp	/^		Compare cmp;$/;"	m	class:BST
comp	map.hpp	/^				Compare comp;$/;"	m	class:ft::map::value_compare
const_iterator	BST_MAP.hpp	/^	typedef ft::BST_iterator<const value_type, node> const_iterator;$/;"	t	class:BST
const_iterator	BST_MAP_NOCOMPARE.hpp	/^	typedef ft::BST_iterator<const value_type, node> const_iterator;$/;"	t	class:BST
const_iterator	map.hpp	/^			typedef ft::BST_iterator<const value_type, node_t> const_iterator;$/;"	t	class:ft::map
const_iterator	vector.hpp	/^	typedef typename ft::random_access_iterator<const T> 		const_iterator;$/;"	t	class:ft::vector
const_pointer	map.hpp	/^			typedef typename Allocator::const_pointer	const_pointer;$/;"	t	class:ft::map
const_pointer	vector.hpp	/^    typedef typename allocator_type::const_pointer				const_pointer;$/;"	t	class:ft::vector
const_reference	map.hpp	/^			typedef typename Allocator::const_reference const_reference;$/;"	t	class:ft::map
const_reference	vector.hpp	/^    typedef typename allocator_type::const_reference			const_reference;$/;"	t	class:ft::vector
const_reverse_iterator	BST_MAP.hpp	/^	typedef ft::BST_iterator_rev<const value_type, node> const_reverse_iterator;$/;"	t	class:BST
const_reverse_iterator	BST_MAP_NOCOMPARE.hpp	/^	typedef ft::BST_iterator_rev<const value_type, node> const_reverse_iterator;$/;"	t	class:BST
const_reverse_iterator	map.hpp	/^			typedef ft::BST_iterator_rev<const value_type, node_t> const_reverse_iterator;$/;"	t	class:ft::map
const_reverse_iterator	vector.hpp	/^	typedef typename ft::random_access_iterator_rev<const T>	const_reverse_iterator;$/;"	t	class:ft::vector
container_type	stack.hpp	/^	typedef Container		container_type;$/;"	t	class:ft::stack
count	BST_iterator.hpp	/^static int count;$/;"	v
count	map.hpp	/^			size_type		count(const key_type& x) const$/;"	f	class:ft::map
dec	main.cpp	/^T	dec(T it, int n)$/;"	f
depth	BST_MAP.hpp	/^	int	depth() { return(maxDepth(root)); }$/;"	f	class:BST
depth	BST_MAP_NOCOMPARE.hpp	/^	int	depth() { return(maxDepth(root)); }$/;"	f	class:BST
depth	BST_old.hpp	/^	int	depth() { return(maxDepth(parent)); }$/;"	f	class:BST
difference_type	map.hpp	/^			typedef	long int							difference_type;$/;"	t	class:ft::map
empty	BST_MAP.hpp	/^	bool	empty() const { return (!_size ? true : false); }$/;"	f	class:BST
empty	map.hpp	/^			bool		empty() const { return(tree.empty()); }$/;"	f	class:ft::map
empty	stack.hpp	/^	bool empty(void) const { return c.empty(); }$/;"	f	class:ft::stack
empty	vector.hpp	/^	bool	empty() const { return (!pos); }$/;"	f	class:ft::vector
enable_if	enable_if.hpp	/^    struct enable_if {};$/;"	s
enable_if	enable_if.hpp	/^    struct enable_if<true> { typedef int type; };$/;"	s
end	BST_MAP.hpp	/^	const_iterator 	end() const { return(iterator(root, NULL, true)); }$/;"	f	class:BST
end	BST_MAP.hpp	/^	iterator 	end() { return(iterator(root, NULL, true)); }$/;"	f	class:BST
end	BST_MAP_NOCOMPARE.hpp	/^	const_iterator 	end() const { return(iterator(root, NULL, true)); }$/;"	f	class:BST
end	BST_MAP_NOCOMPARE.hpp	/^	iterator 	end() { return(iterator(root, NULL, true)); }$/;"	f	class:BST
end	map.hpp	/^			const_iterator 	end() const { return(tree.end()); }$/;"	f	class:ft::map
end	map.hpp	/^			iterator 	end() { return(tree.end()); }$/;"	f	class:ft::map
end	vector.hpp	/^	const_iterator	end() const { return (iterator(_array + pos)); }$/;"	f	class:ft::vector
end	vector.hpp	/^	iterator	end() { return (iterator(_array + pos)); }$/;"	f	class:ft::vector
equal	enable_if.hpp	/^	bool equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2) {$/;"	f	namespace:ft
equal	enable_if.hpp	/^	bool equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, BinaryPredicate pred) {$/;"	f	namespace:ft
equal_range	map.hpp	/^				equal_range(const key_type& x) const$/;"	f	class:ft::map
equal_range	map.hpp	/^				equal_range(const key_type& x)$/;"	f	class:ft::map
erase	map.hpp	/^			size_type erase(const key_type& x)$/;"	f	class:ft::map
erase	map.hpp	/^			void	erase(iterator first, iterator last)$/;"	f	class:ft::map
erase	map.hpp	/^			void	erase(iterator position)$/;"	f	class:ft::map
erase	vector.hpp	/^	iterator erase(iterator first, iterator last)$/;"	f	class:ft::vector
erase	vector.hpp	/^	iterator erase(iterator position) { return(erase(position, position + 1)); }$/;"	f	class:ft::vector
find	map.hpp	/^			const_iterator	find(const key_type& x) const$/;"	f	class:ft::map
find	map.hpp	/^			iterator		find(const key_type& x)$/;"	f	class:ft::map
first	ft_pair.hpp	/^    first_type first;$/;"	m	struct:ft::pair
first_argument_type	map.hpp	/^    typedef Arg1 first_argument_type;$/;"	t	struct:ft::binary_function
first_type	ft_pair.hpp	/^    typedef T1 first_type;$/;"	t	struct:ft::pair
front	vector.hpp	/^	const_reference front() const	{ return (_array[0]); } \/\/returns direct const_reference to container first elem$/;"	f	class:ft::vector
front	vector.hpp	/^	reference front()				{ return (_array[0]); } \/\/returns direct reference to container first elem$/;"	f	class:ft::vector
ft	BST_iterator.bak.hpp	/^namespace ft$/;"	n
ft	BST_iterator.hpp	/^namespace ft$/;"	n
ft	BST_iterator.orig.hpp	/^namespace ft$/;"	n
ft	BST_iterator_rev.hpp	/^namespace ft$/;"	n
ft	enable_if.hpp	/^	namespace ft$/;"	n
ft	ft_pair.hpp	/^namespace ft$/;"	n
ft	map.hpp	/^namespace ft$/;"	n
ft	random_access_iterator.hpp	/^namespace ft$/;"	n
ft	random_access_iterator_rev.hpp	/^namespace ft  $/;"	n
ft	stack.hpp	/^namespace ft{$/;"	n
ft	tree.cpp	/^namespace ft{$/;"	n	file:
ft	vector.hpp	/^namespace ft$/;"	n
ft_erase	main.cpp	/^void	ft_erase(MAP &mp, U param)$/;"	f
ft_erase	main.cpp	/^void	ft_erase(MAP &mp, U param, V param2)$/;"	f
ft_erase	main_erase.cpp	/^void	ft_erase(MAP &mp, U param)$/;"	f
ft_erase	main_erase.cpp	/^void	ft_erase(MAP &mp, U param, V param2)$/;"	f
ft_insert	mainite.cpp	/^void	ft_insert(MAP &mp, U param)$/;"	f
ft_insert	mainite.cpp	/^void	ft_insert(MAP &mp, U param, V param2)$/;"	f
getElemPtr	random_access_iterator.hpp	/^	pointer getElemPtr() const 									{ return (ptr); }$/;"	f	class:ft::random_access_iterator
getElemPtr	random_access_iterator_rev.hpp	/^	pointer getElemPtr() const 									{ return (ptr); }$/;"	f	class:ft::random_access_iterator_rev
getNil	BST_iterator.hpp	/^	bool	getNil() const { return(val_nil); }$/;"	f	class:ft::BST_iterator
getNil	BST_iterator_rev.hpp	/^	bool	getNil() const { return(val_nil); }$/;"	f	class:ft::BST_iterator_rev
getPair	BST.cpp	/^		pair_type* getPair() { return(_pair); }$/;"	f	class:BST::node
getPair	BST_MAP.hpp	/^	value_type& getPair() { return(_pair); }$/;"	f	class:node
getPair	BST_MAP_NOCOMPARE.hpp	/^	value_type& getPair() { return(_pair); }$/;"	f	class:node
getParent	BST.cpp	/^	node* getParent() { return (root); }$/;"	f	class:BST	file:
getParent	BST_old.hpp	/^	node_t* getParent() { return (parent); }$/;"	f	class:BST
getPos	BST_iterator.bak.hpp	/^	ptr		getPos(void) const { return(pos); }$/;"	f	class:ft::BST_iterator
getPos	BST_iterator.orig.hpp	/^	ptr		getPos(void) const { return(pos); }$/;"	f	class:ft::BST_iterator
getPtr	BST_iterator.hpp	/^	ptr		getPtr() const { return(val_ptr); }$/;"	f	class:ft::BST_iterator
getPtr	BST_iterator_rev.hpp	/^	ptr		getPtr() const { return(val_ptr); }$/;"	f	class:ft::BST_iterator_rev
getRoot	BST_MAP.hpp	/^	node* getRoot() const { return (root); }$/;"	f	class:BST
getRoot	BST_MAP_NOCOMPARE.hpp	/^	node* getRoot() { return (root); }$/;"	f	class:BST
getRoot	BST_iterator.bak.hpp	/^	ptr		getRoot(void) const { return(root); }$/;"	f	class:ft::BST_iterator
getRoot	BST_iterator.hpp	/^	ptr		getRoot() const { return(root); }$/;"	f	class:ft::BST_iterator
getRoot	BST_iterator.orig.hpp	/^	ptr		getRoot(void) const { return(root); }$/;"	f	class:ft::BST_iterator
getRoot	map.hpp	/^			node_t* getRoot() { return(tree.getRoot()); }$/;"	f	class:ft::map
getSize	BST.cpp	/^	size_t	getSize(void) { return (size); }$/;"	f	class:BST	file:
getSize	BST_MAP.hpp	/^	size_t	getSize(void) const { return (_size); }$/;"	f	class:BST
getSize	BST_MAP_NOCOMPARE.hpp	/^	size_t	getSize(void) const { return (_size); }$/;"	f	class:BST
getSize	BST_old.hpp	/^	size_t	getSize(void) { return (size); }$/;"	f	class:BST
getValue	BST_old.hpp	/^	T1	getValue() { return (value); }$/;"	f	class:node
height	BST_MAP.hpp	/^	int	height;$/;"	m	class:node
height	BST_MAP_NOCOMPARE.hpp	/^	int	height;$/;"	m	class:node
inc	random_access_iterator.hpp	/^	#define inc(/;"	d
inc2	random_access_iterator_rev.hpp	/^	#define inc2(/;"	d
inorder	BST_old.hpp	/^	node_t* inorder(node_t* loc)$/;"	f	class:BST
inorderPredecessor	BST_MAP.hpp	/^	node*	inorderPredecessor(node* p) const$/;"	f	class:BST
inorderPredecessor	BST_iterator.bak.hpp	/^	ptr	inorderPredecessor(ptr p)$/;"	f	class:ft::BST_iterator
inorderPredecessor	BST_iterator.hpp	/^	ptr	inorderPredecessor(ptr p)$/;"	f	class:ft::BST_iterator
inorderPredecessor	BST_iterator.orig.hpp	/^	ptr	inorderPredecessor(ptr p)$/;"	f	class:ft::BST_iterator
inorderPredecessor	BST_iterator_rev.hpp	/^	ptr	inorderPredecessor(ptr p)$/;"	f	class:ft::BST_iterator_rev
inorderSucessor	BST_MAP.hpp	/^	node*	inorderSucessor(node* p) const$/;"	f	class:BST
inorderSucessor	BST_iterator.bak.hpp	/^	ptr	inorderSucessor(ptr p)$/;"	f	class:ft::BST_iterator
inorderSucessor	BST_iterator.hpp	/^	ptr	inorderSucessor(ptr p)$/;"	f	class:ft::BST_iterator
inorderSucessor	BST_iterator.orig.hpp	/^	ptr	inorderSucessor(ptr p)$/;"	f	class:ft::BST_iterator
inorderSucessor	BST_iterator_rev.hpp	/^	ptr	inorderSucessor(ptr p)$/;"	f	class:ft::BST_iterator_rev
insert	BST_MAP.hpp	/^	node* insert(const value_type& $pair){ root = insertAt(root, $pair); return(node_ret(GET,NULL, NULL)); }$/;"	f	class:BST
insert	BST_MAP_NOCOMPARE.hpp	/^	node* insert(const value_type& $pair)$/;"	f	class:BST
insert	BST_old.hpp	/^	void insert(T1 value){ parent = insertAt(parent, value); }$/;"	f	class:BST
insert	map.hpp	/^				void	insert(InputIterator first, InputIterator last)$/;"	f	class:ft::map
insert	map.hpp	/^			iterator insert (iterator position, const value_type& val)$/;"	f	class:ft::map
insert	map.hpp	/^			pair<iterator, bool> insert(const value_type& x)$/;"	f	class:ft::map
insert	vector.hpp	/^	iterator insert (iterator position, const value_type& val)$/;"	f	class:ft::vector
insert	vector.hpp	/^	void	insert(iterator position, InputIterator first, InputIterator last,$/;"	f	class:ft::vector
insert	vector.hpp	/^	void insert (iterator position, size_type n, const value_type& val)$/;"	f	class:ft::vector
insertAt	BST_MAP.hpp	/^	node*	insertAt(node* at, const value_type& $pair, node* parent = NULL)$/;"	f	class:BST
insertAt	BST_MAP_NOCOMPARE.hpp	/^	node*	insertAt(node* at, const value_type& $pair)$/;"	f	class:BST
insertAt	BST_old.hpp	/^	node_t* insertAt(node_t* at, T1 value)$/;"	f	class:BST
is_integral	enable_if.hpp	/^    struct is_integral { static const bool value = false; };$/;"	s
is_integral	enable_if.hpp	/^    struct is_integral<bool> { static const bool value = true; };$/;"	s
is_integral	enable_if.hpp	/^    struct is_integral<char> { static const bool value = true; };$/;"	s
is_integral	enable_if.hpp	/^    struct is_integral<int> { static const bool value = true; };$/;"	s
is_integral	enable_if.hpp	/^    struct is_integral<long long> { static const bool value = true; };$/;"	s
is_integral	enable_if.hpp	/^    struct is_integral<long> { static const bool value = true; };$/;"	s
is_integral	enable_if.hpp	/^    struct is_integral<short> { static const bool value = true; };$/;"	s
is_integral	enable_if.hpp	/^    struct is_integral<unsigned char> { static const bool value = true; };$/;"	s
is_integral	enable_if.hpp	/^    struct is_integral<unsigned int> { static const bool value = true; };$/;"	s
is_integral	enable_if.hpp	/^    struct is_integral<unsigned long long> { static const bool value = true; };$/;"	s
is_integral	enable_if.hpp	/^    struct is_integral<unsigned long> { static const bool value = true; };$/;"	s
is_integral	enable_if.hpp	/^    struct is_integral<unsigned short> { static const bool value = true; };$/;"	s
iter	main.cpp	/^static int iter = 0;$/;"	v	file:
iter	main_erase.cpp	/^static int iter = 0;$/;"	v	file:
iter	mainite.cpp	/^static int iter = 0;$/;"	v	file:
iterator	BST_MAP.hpp	/^	typedef ft::BST_iterator<value_type, node> iterator;$/;"	t	class:BST
iterator	BST_MAP_NOCOMPARE.hpp	/^	typedef ft::BST_iterator<value_type, node> iterator;$/;"	t	class:BST
iterator	mainite.cpp	/^typedef TESTED_NAMESPACE::map<T1, T2>::iterator iterator;$/;"	t	file:
iterator	map.hpp	/^			typedef ft::BST_iterator<value_type, node_t> iterator;$/;"	t	class:ft::map
iterator	vector.hpp	/^	typedef typename ft::random_access_iterator<T>				iterator;$/;"	t	class:ft::vector
key_comp	map.hpp	/^			Key_compare		key_comp() const { return (Key_compare()); }$/;"	f	class:ft::map
key_type	map.hpp	/^			typedef Key									key_type;$/;"	t	class:ft::map
left	BST.cpp	/^		node* left;$/;"	m	class:BST::node	file:
left	BST_MAP.hpp	/^	node* left;$/;"	m	class:node
left	BST_MAP_NOCOMPARE.hpp	/^	node* left;$/;"	m	class:node
left	BST_old.hpp	/^	node_t* left;$/;"	m	class:node
leftRotate	BST_MAP.hpp	/^	node* leftRotate(node *x)$/;"	f	class:BST
leftRotate	BST_MAP_NOCOMPARE.hpp	/^	node* leftRotate(node *x)$/;"	f	class:BST
less	map.hpp	/^	template <class T> struct less : binary_function <T,T,bool> {$/;"	s	namespace:ft
lexicographical_compare	enable_if.hpp	/^  	bool lexicographical_compare (InputIterator1 first1, InputIterator1 last1,$/;"	f	namespace:ft
lower_bound	BST_MAP.hpp	/^	node*	lower_bound(const Key& x) const$/;"	f	class:BST
lower_bound	map.hpp	/^			const_iterator		lower_bound(const key_type& x) const$/;"	f	class:ft::map
lower_bound	map.hpp	/^			iterator		lower_bound(const key_type& x)$/;"	f	class:ft::map
main	BST.cpp	/^int	main(void)$/;"	f
main	main.cpp	/^int		main(void)$/;"	f
main	main_erase.cpp	/^int		main(void)$/;"	f
main	main_perf_map.cpp	/^int	main(void)$/;"	f
main	mainite.cpp	/^int		main(void)$/;"	f
main	tree.cpp	/^int	main(int argc, char **argv)$/;"	f
make_pair	ft_pair.hpp	/^    $OP_CONTEXT ft::pair<T1,T2> make_pair(T1 x, T2 y)										{ return (ft::pair<T1, T2>(x, y)); }$/;"	f	namespace:ft
map	map.hpp	/^				map(InputIterator first, InputIterator last, const Compare& comp = Compare(), const Allocator& = Allocator(), typename enable_if<!is_integral<InputIterator>::value >::type* = 0) : tree(value_compare(comp))$/;"	f	class:ft::map
map	map.hpp	/^			explicit map(const Compare& comp = Compare(), const Allocator& = Allocator()) : tree(value_compare(comp))$/;"	f	class:ft::map
map	map.hpp	/^			map(const map<Key, T, Compare, Allocator>& X) : tree(value_compare(Compare()))$/;"	f	class:ft::map
map	map.hpp	/^		class map$/;"	c	namespace:ft
mapped_type	map.hpp	/^			typedef T									mapped_type;$/;"	t	class:ft::map
max	BST_MAP.hpp	/^	int	max(node* left, node* right)$/;"	f	class:BST
max	BST_MAP_NOCOMPARE.hpp	/^	int	max(node* left, node* right)$/;"	f	class:BST
maxDepth	BST_MAP.hpp	/^	int maxDepth(node* node)$/;"	f	class:BST
maxDepth	BST_MAP_NOCOMPARE.hpp	/^	int maxDepth(node* node)$/;"	f	class:BST
maxDepth	BST_old.hpp	/^	int maxDepth(node<int>* node)$/;"	f	class:BST
maxL	BST_MAP.hpp	/^	node* maxL(node* loc) const$/;"	f	class:BST
maxL	BST_MAP_NOCOMPARE.hpp	/^	node* maxL(node* loc) const$/;"	f	class:BST
maxL	BST_MAP_NOCOMPARE.hpp	/^	node* maxL(node* loc)$/;"	f	class:BST
maxL	BST_iterator.bak.hpp	/^	ptr maxL(ptr loc)$/;"	f	class:ft::BST_iterator
maxL	BST_iterator.hpp	/^	ptr maxL(ptr loc)$/;"	f	class:ft::BST_iterator
maxL	BST_iterator.orig.hpp	/^	ptr maxL(ptr loc)$/;"	f	class:ft::BST_iterator
maxL	BST_iterator_rev.hpp	/^	ptr maxL(ptr loc) const$/;"	f	class:ft::BST_iterator_rev
maxR	BST_MAP.hpp	/^	node* maxR(node* loc) const$/;"	f	class:BST
maxR	BST_MAP_NOCOMPARE.hpp	/^	node* maxR(node* loc) const$/;"	f	class:BST
maxR	BST_MAP_NOCOMPARE.hpp	/^	node* maxR(node* loc)$/;"	f	class:BST
maxR	BST_iterator.bak.hpp	/^	ptr maxR(ptr loc)$/;"	f	class:ft::BST_iterator
maxR	BST_iterator.hpp	/^	ptr maxR(ptr loc)$/;"	f	class:ft::BST_iterator
maxR	BST_iterator.orig.hpp	/^	ptr maxR(ptr loc)$/;"	f	class:ft::BST_iterator
maxR	BST_iterator_rev.hpp	/^	ptr maxR(ptr loc) const$/;"	f	class:ft::BST_iterator_rev
max_size	map.hpp	/^			size_type	max_size() const { return(_Base.max_size()); }$/;"	f	class:ft::map
max_size	vector.hpp	/^	size_type max_size() const 		{ return (_Base.max_size());} \/\/return max size$/;"	f	class:ft::vector
newNode	BST.cpp	/^	node* newNode(Key value)$/;"	f	class:BST	file:
newNode	BST_MAP.hpp	/^	node* newNode(const value_type& $pair)$/;"	f	class:BST
newNode	BST_MAP.hpp	/^	node* newNode(const value_type& $pair, node* cpy)$/;"	f	class:BST
newNode	BST_MAP_NOCOMPARE.hpp	/^	node* newNode(const value_type& $pair)$/;"	f	class:BST
newNode	BST_MAP_NOCOMPARE.hpp	/^	node* newNode(const value_type& $pair, node* cpy)$/;"	f	class:BST
newNode	BST_old.hpp	/^	node_t* newNode(T1 value)$/;"	f	class:BST
newPair	ft_pair.hpp	/^#define newPair(/;"	d
nil	BST_iterator.orig.hpp	/^	bool	nil;$/;"	m	class:ft::BST_iterator
node	BST.cpp	/^		node() : left(NULL), right(NULL), parent(NULL){}$/;"	f	class:BST::node
node	BST.cpp	/^	class node$/;"	c	class:BST	file:
node	BST_MAP.hpp	/^	node() : left(NULL), right(NULL), parent(NULL), height(1) {}$/;"	f	class:node
node	BST_MAP.hpp	/^	node(value_type $pair) : left(NULL), right(NULL),  parent(NULL), height(1), _pair($pair) {}$/;"	f	class:node
node	BST_MAP.hpp	/^	typedef node<Key, T> node;$/;"	t	class:BST
node	BST_MAP.hpp	/^class node$/;"	c
node	BST_MAP_NOCOMPARE.hpp	/^	node() : left(NULL), right(NULL),  height(1), parent(NULL){}$/;"	f	class:node
node	BST_MAP_NOCOMPARE.hpp	/^	node(value_type $pair) : left(NULL), right(NULL),  parent(NULL), height(1), _pair($pair) {}$/;"	f	class:node
node	BST_MAP_NOCOMPARE.hpp	/^	typedef node<Key, T, Allocator> node;$/;"	t	class:BST
node	BST_MAP_NOCOMPARE.hpp	/^class node$/;"	c
node	BST_old.hpp	/^	node() : left(NULL), right(NULL), parent(NULL){}$/;"	f	class:node
node	BST_old.hpp	/^class node$/;"	c
node_ret	BST_MAP.hpp	/^	node*	node_ret(bool mode, node* at, node* inserted)$/;"	f	class:BST
node_ret	BST_MAP_NOCOMPARE.hpp	/^	node*	node_ret(bool mode, node* at, node* inserted)$/;"	f	class:BST
node_t	BST_old.hpp	/^	typedef node<T1, T2> node_t;$/;"	t	class:BST
node_t	BST_old.hpp	/^	typedef node<T1, T2> node_t;$/;"	t	class:node
node_t	map.hpp	/^			typedef node<Key, T> 						node_t;$/;"	t	class:ft::map
operator !=	BST_iterator.bak.hpp	/^	bool operator!=(const BST_iterator& src) const { return (pos != src.pos); }$/;"	f	class:ft::BST_iterator
operator !=	BST_iterator.hpp	/^	bool operator!=(const BST_iterator& src) const$/;"	f	class:ft::BST_iterator
operator !=	BST_iterator.hpp	/^$OP_CONTEXT operator!=($OP_PARAM_CONTEXT)$/;"	f	namespace:ft
operator !=	BST_iterator.orig.hpp	/^	bool operator!=(const BST_iterator& src) const { return (nil ? NULL : pos != src.pos); }$/;"	f	class:ft::BST_iterator
operator !=	BST_iterator_rev.hpp	/^	bool operator!=(const BST_iterator_rev& src) const$/;"	f	class:ft::BST_iterator_rev
operator !=	BST_iterator_rev.hpp	/^$OP_CONTEXT operator!=($OP_PARAM_CONTEXT)$/;"	f	namespace:ft
operator !=	ft_pair.hpp	/^    $OP_CONTEXT bool operator!= ($OP_CONTEXT_PARAM)	{ return !(left == right); }$/;"	f	namespace:ft
operator !=	map.hpp	/^			bool operator!=(const map<Key,T,Compare,Allocator>& x,const map<Key,T,Compare,Allocator>& y) { return (!(x == y)); }$/;"	f	namespace:ft
operator !=	random_access_iterator.hpp	/^	$OP_CONTEXT operator!=($OP_CONTEXT_PARAM) 					{ return (left.getElemPtr() != right.getElemPtr() ); }$/;"	f	class:ft::random_access_iterator
operator !=	random_access_iterator_rev.hpp	/^	$OP_CONTEXT operator!=($OP_CONTEXT_PARAM) 					{ return (left.base() != right.base()); }$/;"	f	class:ft::random_access_iterator_rev
operator !=	stack.hpp	/^	$OP_CONTEXT operator!= ($OP_CONTEXT_PARAM) { return left.c != right.c; }$/;"	f	class:ft::stack
operator !=	vector.hpp	/^	$OP_CONTEXT operator!=($OP_CONTEXT_PARAM)	{ return (!(left == right)); }$/;"	f	class:ft::vector
operator ()	map.hpp	/^				bool operator()(const value_type& x, const value_type& y) const { return (comp(x.first, y.first)); }$/;"	f	class:ft::map::value_compare
operator ()	map.hpp	/^	  bool operator() (const T& x, const T& y) const {return x<y;}$/;"	f	struct:ft::less
operator *	BST_iterator.bak.hpp	/^	T&		operator*(void) const { return(pos->_pair); }$/;"	f	class:ft::BST_iterator
operator *	BST_iterator.hpp	/^	T&		operator*(void) const { return(val_ptr->_pair); }$/;"	f	class:ft::BST_iterator
operator *	BST_iterator.orig.hpp	/^	T&		operator*(void) const { return(pos->_pair); }$/;"	f	class:ft::BST_iterator
operator *	BST_iterator_rev.hpp	/^	T&		operator*(void) const { return(val_ptr->_pair); }$/;"	f	class:ft::BST_iterator_rev
operator *	random_access_iterator.hpp	/^	reference	operator*() const								{ return (*ptr); }$/;"	f	class:ft::random_access_iterator
operator *	random_access_iterator_rev.hpp	/^	reference	operator*() const								{ return (*ptr); }$/;"	f	class:ft::random_access_iterator_rev
operator +	random_access_iterator.hpp	/^	friend this_class operator+(int n, const this_class& src)	{ (void)src;this_class ret(src); return (ret += n); }$/;"	f	class:ft::random_access_iterator
operator +	random_access_iterator.hpp	/^	this_class	operator+(int n)								{ this_class ret(*this); inc(ret.ptr, n); return (ret); }$/;"	f	class:ft::random_access_iterator
operator +	random_access_iterator_rev.hpp	/^	friend this_class operator+(int n, const this_class& src)	{ (void)src;this_class ret(src); return (ret += n); }$/;"	f	class:ft::random_access_iterator_rev
operator +	random_access_iterator_rev.hpp	/^	this_class	operator+(int n)								{ this_class ret(*this); sub2(ret.ptr, n); return (ret); }$/;"	f	class:ft::random_access_iterator_rev
operator ++	BST_iterator.bak.hpp	/^	BST_iterator operator++(int)$/;"	f	class:ft::BST_iterator
operator ++	BST_iterator.bak.hpp	/^	BST_iterator& operator++(void)$/;"	f	class:ft::BST_iterator
operator ++	BST_iterator.hpp	/^	BST_iterator operator++(int)$/;"	f	class:ft::BST_iterator
operator ++	BST_iterator.hpp	/^	BST_iterator& operator++(void)$/;"	f	class:ft::BST_iterator
operator ++	BST_iterator.orig.hpp	/^	BST_iterator operator++(int)$/;"	f	class:ft::BST_iterator
operator ++	BST_iterator.orig.hpp	/^	BST_iterator& operator++(void)$/;"	f	class:ft::BST_iterator
operator ++	BST_iterator_rev.hpp	/^	BST_iterator_rev operator++(int)$/;"	f	class:ft::BST_iterator_rev
operator ++	BST_iterator_rev.hpp	/^	BST_iterator_rev& operator++(void)$/;"	f	class:ft::BST_iterator_rev
operator ++	random_access_iterator.hpp	/^	this_class	operator++(int)									{ this_class ret(ptr); operator++(); return (ret); }$/;"	f	class:ft::random_access_iterator
operator ++	random_access_iterator.hpp	/^	this_class& operator++()									{ inc(ptr, 1); return (*this); }$/;"	f	class:ft::random_access_iterator
operator ++	random_access_iterator_rev.hpp	/^	this_class	operator++(int)									{ this_class ret(ptr); operator++(); return (ret); }$/;"	f	class:ft::random_access_iterator_rev
operator ++	random_access_iterator_rev.hpp	/^	this_class& operator++()									{ sub2(ptr, 1); return (*this); }$/;"	f	class:ft::random_access_iterator_rev
operator +=	random_access_iterator.hpp	/^	this_class& operator+=(int n)								{ inc(ptr, n); return (*this); }$/;"	f	class:ft::random_access_iterator
operator +=	random_access_iterator_rev.hpp	/^	this_class& operator+=(int n)								{ sub2(ptr, n); return (*this); }$/;"	f	class:ft::random_access_iterator_rev
operator -	random_access_iterator.hpp	/^	friend this_class operator-(int n, const this_class& src)	{ (void)src;this_class ret(src); return (ret -= n); }$/;"	f	class:ft::random_access_iterator
operator -	random_access_iterator.hpp	/^	range operator-(this_class it) const 						{ return (this->ptr - it.ptr);}$/;"	f	class:ft::random_access_iterator
operator -	random_access_iterator.hpp	/^	this_class	operator-(int n)								{ this_class ret(*this); sub(ret.ptr, n); return (ret); }$/;"	f	class:ft::random_access_iterator
operator -	random_access_iterator_rev.hpp	/^	friend this_class operator-(int n, const this_class& src)	{ (void)src;this_class ret(src); return (ret -= n); }$/;"	f	class:ft::random_access_iterator_rev
operator -	random_access_iterator_rev.hpp	/^	range operator-(this_class it) const 						{ return (it.ptr - this->ptr); }$/;"	f	class:ft::random_access_iterator_rev
operator -	random_access_iterator_rev.hpp	/^	this_class	operator-(int n)								{ this_class ret(*this); inc2(ret.ptr, n); return (ret); }$/;"	f	class:ft::random_access_iterator_rev
operator --	BST_iterator.bak.hpp	/^	BST_iterator operator--(int)$/;"	f	class:ft::BST_iterator
operator --	BST_iterator.bak.hpp	/^	BST_iterator& operator--(void)$/;"	f	class:ft::BST_iterator
operator --	BST_iterator.hpp	/^	BST_iterator operator--(int)$/;"	f	class:ft::BST_iterator
operator --	BST_iterator.hpp	/^	BST_iterator& operator--(void)$/;"	f	class:ft::BST_iterator
operator --	BST_iterator.orig.hpp	/^	BST_iterator operator--(int)$/;"	f	class:ft::BST_iterator
operator --	BST_iterator.orig.hpp	/^	BST_iterator& operator--(void)$/;"	f	class:ft::BST_iterator
operator --	BST_iterator_rev.hpp	/^	BST_iterator_rev operator--(int)$/;"	f	class:ft::BST_iterator_rev
operator --	BST_iterator_rev.hpp	/^	BST_iterator_rev& operator--(void)$/;"	f	class:ft::BST_iterator_rev
operator --	random_access_iterator.hpp	/^	this_class 	operator--(int)									{ this_class ret(ptr); operator--(); return (ret); }$/;"	f	class:ft::random_access_iterator
operator --	random_access_iterator.hpp	/^	this_class& operator--()									{ sub(ptr, 1); return (*this); }$/;"	f	class:ft::random_access_iterator
operator --	random_access_iterator_rev.hpp	/^	this_class 	operator--(int)									{ this_class ret(ptr); operator--(); return (ret); }$/;"	f	class:ft::random_access_iterator_rev
operator --	random_access_iterator_rev.hpp	/^	this_class& operator--()									{ inc2(ptr, 1); return (*this); }$/;"	f	class:ft::random_access_iterator_rev
operator -=	random_access_iterator.hpp	/^	this_class& operator-=(int n)								{ sub(ptr, n); return (*this); }$/;"	f	class:ft::random_access_iterator
operator -=	random_access_iterator_rev.hpp	/^	this_class& operator-=(int n)								{ inc2(ptr, n); return (*this); }$/;"	f	class:ft::random_access_iterator_rev
operator ->	BST_iterator.bak.hpp	/^	T*		operator->(void) const { return (&(operator*())); }$/;"	f	class:ft::BST_iterator
operator ->	BST_iterator.hpp	/^	T*		operator->(void) const { return (&(operator*())); }$/;"	f	class:ft::BST_iterator
operator ->	BST_iterator.orig.hpp	/^	T*		operator->(void) const { return (&(operator*())); }$/;"	f	class:ft::BST_iterator
operator ->	BST_iterator_rev.hpp	/^	T*		operator->(void) const { return (&(operator*())); }$/;"	f	class:ft::BST_iterator_rev
operator ->	random_access_iterator.hpp	/^	pointer	operator->() const									{ return (ptr); }$/;"	f	class:ft::random_access_iterator
operator ->	random_access_iterator_rev.hpp	/^	pointer	operator->() const									{ return (ptr); }$/;"	f	class:ft::random_access_iterator_rev
operator <	ft_pair.hpp	/^    $OP_CONTEXT bool operator<  ($OP_CONTEXT_PARAM)	{ return (left.first < right.first || (!(right.first < left.first) && left.second < right.second)); }$/;"	f	namespace:ft
operator <	map.hpp	/^			bool operator< (const map<Key,T,Compare,Allocator>& x,const map<Key,T,Compare,Allocator>& y)$/;"	f	namespace:ft
operator <	random_access_iterator.hpp	/^	$OP_CONTEXT operator<($OP_CONTEXT_PARAM) 					{ return (left.getElemPtr() < right.getElemPtr() ); }$/;"	f	class:ft::random_access_iterator
operator <	random_access_iterator_rev.hpp	/^	$OP_CONTEXT operator<($OP_CONTEXT_PARAM) 					{ return (left.base() > right.base()); }$/;"	f	class:ft::random_access_iterator_rev
operator <	stack.hpp	/^	$OP_CONTEXT operator<  ($OP_CONTEXT_PARAM) { return left.c < right.c; }$/;"	f	class:ft::stack
operator <	vector.hpp	/^	$OP_CONTEXT operator<($OP_CONTEXT_PARAM) { return(ft::lexicographical_compare($/;"	f	class:ft::vector
operator <=	ft_pair.hpp	/^    $OP_CONTEXT bool operator<= ($OP_CONTEXT_PARAM)	{ return !(right < left); }$/;"	f	namespace:ft
operator <=	map.hpp	/^			bool operator<=(const map<Key,T,Compare,Allocator>& x,const map<Key,T,Compare,Allocator>& y) { return (!(y < x)); }$/;"	f	namespace:ft
operator <=	random_access_iterator.hpp	/^	$OP_CONTEXT operator<=($OP_CONTEXT_PARAM) 					{ return (left.getElemPtr() <= right.getElemPtr() ); }$/;"	f	class:ft::random_access_iterator
operator <=	random_access_iterator_rev.hpp	/^	$OP_CONTEXT operator<=($OP_CONTEXT_PARAM) 					{ return (left.base() >= right.base()); }$/;"	f	class:ft::random_access_iterator_rev
operator <=	stack.hpp	/^	$OP_CONTEXT operator<= ($OP_CONTEXT_PARAM) { return left.c <= right.c; }$/;"	f	class:ft::stack
operator <=	vector.hpp	/^	$OP_CONTEXT operator<=($OP_CONTEXT_PARAM)	{ return (!(right < left)); }$/;"	f	class:ft::vector
operator =	BST_MAP.hpp	/^	node& operator=(const node* src)$/;"	f	class:node
operator =	BST_MAP_NOCOMPARE.hpp	/^	node& operator=(const node* src)$/;"	f	class:node
operator =	BST_iterator.bak.hpp	/^	BST_iterator& operator=(const BST_iterator& src)$/;"	f	class:ft::BST_iterator
operator =	BST_iterator.bak.hpp	/^$OP_CONTEXT operator=($OP_PARAM_CONTEXT) { return(left.getPos() = right.getPos()); }$/;"	f	namespace:ft
operator =	BST_iterator.hpp	/^	BST_iterator& operator=(const BST_iterator& src)$/;"	f	class:ft::BST_iterator
operator =	BST_iterator.orig.hpp	/^	BST_iterator& operator=(const BST_iterator& src)$/;"	f	class:ft::BST_iterator
operator =	BST_iterator.orig.hpp	/^$OP_CONTEXT operator=($OP_PARAM_CONTEXT) { return(left.getPos() = right.getPos()); }$/;"	f	namespace:ft
operator =	BST_iterator_rev.hpp	/^	BST_iterator_rev& operator=(const BST_iterator_rev& src)$/;"	f	class:ft::BST_iterator_rev
operator =	ft_pair.hpp	/^    pair& operator= (const pair& src)$/;"	f	struct:ft::pair
operator =	map.hpp	/^				operator=(const map<Key, T, Compare, Allocator>& X)$/;"	f	class:ft::map
operator =	random_access_iterator.hpp	/^	this_class& operator=(const this_class& src)				{ if (this == &src) return (*this); ptr = src.ptr; return (*this); }$/;"	f	class:ft::random_access_iterator
operator =	random_access_iterator_rev.hpp	/^	this_class& operator=(const this_class& src)				{ if (this == &src) return (*this); ptr = src.ptr; return (*this); }$/;"	f	class:ft::random_access_iterator_rev
operator =	vector.hpp	/^ 	vector& operator= (const vector& src)$/;"	f	class:ft::vector
operator ==	BST_iterator.bak.hpp	/^	bool operator==(const BST_iterator& src) const { return (pos == src.pos); }$/;"	f	class:ft::BST_iterator
operator ==	BST_iterator.bak.hpp	/^$OP_CONTEXT operator==($OP_PARAM_CONTEXT) { return(left.getPos() == right.getPos()); }$/;"	f
operator ==	BST_iterator.hpp	/^	bool operator==(const BST_iterator& src) const$/;"	f	class:ft::BST_iterator
operator ==	BST_iterator.hpp	/^$OP_CONTEXT operator==($OP_PARAM_CONTEXT)$/;"	f	namespace:ft
operator ==	BST_iterator.orig.hpp	/^	bool operator==(const BST_iterator& src) const { return (nil ? NULL : pos == src.pos); }$/;"	f	class:ft::BST_iterator
operator ==	BST_iterator.orig.hpp	/^$OP_CONTEXT operator==($OP_PARAM_CONTEXT) { return(left.getPos() == right.getPos()); }$/;"	f
operator ==	BST_iterator_rev.hpp	/^	bool operator==(const BST_iterator_rev& src) const$/;"	f	class:ft::BST_iterator_rev
operator ==	BST_iterator_rev.hpp	/^$OP_CONTEXT operator==($OP_PARAM_CONTEXT)$/;"	f	namespace:ft
operator ==	ft_pair.hpp	/^    $OP_CONTEXT bool operator== ($OP_CONTEXT_PARAM)	{ return (left.first == right.first && left.second == right.second); }$/;"	f	namespace:ft
operator ==	map.hpp	/^			bool operator==(const map<Key,T,Compare,Allocator>& x,const map<Key,T,Compare,Allocator>& y)$/;"	f	namespace:ft
operator ==	random_access_iterator.hpp	/^	$OP_CONTEXT operator==($OP_CONTEXT_PARAM) 					{ return (left.getElemPtr() == right.getElemPtr() ); }$/;"	f	class:ft::random_access_iterator
operator ==	random_access_iterator_rev.hpp	/^	$OP_CONTEXT operator==($OP_CONTEXT_PARAM) 					{ return (left.base() == right.base()); }$/;"	f	class:ft::random_access_iterator_rev
operator ==	stack.hpp	/^	$OP_CONTEXT operator== ($OP_CONTEXT_PARAM) { return left.c == right.c; }$/;"	f	class:ft::stack
operator ==	vector.hpp	/^	$OP_CONTEXT operator==($OP_CONTEXT_PARAM)$/;"	f	class:ft::vector
operator >	ft_pair.hpp	/^    $OP_CONTEXT bool operator>  ($OP_CONTEXT_PARAM)	{ return (right < left); }$/;"	f	namespace:ft
operator >	map.hpp	/^			bool operator> (const map<Key,T,Compare,Allocator>& x,const map<Key,T,Compare,Allocator>& y){ return (y < x);}$/;"	f	namespace:ft
operator >	random_access_iterator.hpp	/^	$OP_CONTEXT operator>($OP_CONTEXT_PARAM) 					{ return (left.getElemPtr() > right.getElemPtr() ); }$/;"	f	class:ft::random_access_iterator
operator >	random_access_iterator_rev.hpp	/^	$OP_CONTEXT operator>($OP_CONTEXT_PARAM) 					{ return (left.base() < right.base()); }$/;"	f	class:ft::random_access_iterator_rev
operator >	stack.hpp	/^	$OP_CONTEXT operator>  ($OP_CONTEXT_PARAM) { return left.c > right.c; }$/;"	f	class:ft::stack
operator >	vector.hpp	/^	$OP_CONTEXT operator>($OP_CONTEXT_PARAM)	{ return (right < left); }$/;"	f	class:ft::vector
operator >=	ft_pair.hpp	/^    $OP_CONTEXT bool operator>= ($OP_CONTEXT_PARAM)	{ return !(left < right); }$/;"	f	namespace:ft
operator >=	map.hpp	/^			bool operator>=(const map<Key,T,Compare,Allocator>& x,const map<Key,T,Compare,Allocator>& y) { return (!(x < y)); }$/;"	f	namespace:ft
operator >=	random_access_iterator.hpp	/^	$OP_CONTEXT operator>=($OP_CONTEXT_PARAM) 					{ return (left.getElemPtr() >= right.getElemPtr() ); }$/;"	f	class:ft::random_access_iterator
operator >=	random_access_iterator_rev.hpp	/^	$OP_CONTEXT operator>=($OP_CONTEXT_PARAM) 					{ return (left.base() <= right.base()); }$/;"	f	class:ft::random_access_iterator_rev
operator >=	stack.hpp	/^	$OP_CONTEXT operator>= ($OP_CONTEXT_PARAM) { return left.c >= right.c; }$/;"	f	class:ft::stack
operator >=	vector.hpp	/^	$OP_CONTEXT operator>=($OP_CONTEXT_PARAM)	{ return (!(left < right)); }$/;"	f	class:ft::vector
operator BST_iterator<const T, BST_NODE>	BST_iterator.bak.hpp	/^	operator BST_iterator<const T, BST_NODE>(void)$/;"	f	class:ft::BST_iterator
operator BST_iterator<const T, BST_NODE>	BST_iterator.hpp	/^	operator BST_iterator<const T, BST_NODE>(void)$/;"	f	class:ft::BST_iterator
operator BST_iterator<const T, BST_NODE>	BST_iterator.orig.hpp	/^	operator BST_iterator<const T, BST_NODE>(void)$/;"	f	class:ft::BST_iterator
operator BST_iterator_rev<const T, BST_NODE>	BST_iterator_rev.hpp	/^	operator BST_iterator_rev<const T, BST_NODE>(void)$/;"	f	class:ft::BST_iterator_rev
operator []	map.hpp	/^			T&			operator[](const key_type& x)$/;"	f	class:ft::map
operator []	random_access_iterator.hpp	/^	reference	operator[](int n)								{ pointer ret(ptr + n);return (*ret); }$/;"	f	class:ft::random_access_iterator
operator []	random_access_iterator_rev.hpp	/^	reference	operator[](int n)								{ pointer ret(ptr - n);return (*ret); }$/;"	f	class:ft::random_access_iterator_rev
operator []	vector.hpp	/^	const_reference operator[](size_type n) const { return (_array[n]); } \/\/ return const_reference of element at n position of container$/;"	f	class:ft::vector
operator []	vector.hpp	/^	reference operator[](size_type n) { return (_array[n]);} \/\/ return reference of element at n position of container$/;"	f	class:ft::vector
operator random_access_iterator<const T>	random_access_iterator.hpp	/^	operator random_access_iterator<const T> (void) 			{ return random_access_iterator<const T>(ptr); }$/;"	f	class:ft::random_access_iterator
operator random_access_iterator_rev<const T>	random_access_iterator_rev.hpp	/^	operator random_access_iterator_rev<const T> (void) 		{ return random_access_iterator_rev<const T>(ptr); }$/;"	f	class:ft::random_access_iterator_rev
pair	ft_pair.hpp	/^        pair (const pair<U, V>& src) : first(src.first), second(src.second) {}$/;"	f	struct:ft::pair
pair	ft_pair.hpp	/^    pair (const first_type& a, const second_type& b) : first(a), second(b) {}$/;"	f	struct:ft::pair
pair	ft_pair.hpp	/^    pair() : first(), second() {}$/;"	f	struct:ft::pair
pair	ft_pair.hpp	/^struct pair$/;"	s	namespace:ft
pair_type	BST.cpp	/^		typedef ft::pair<const Key, T2> pair_type;$/;"	t	class:BST::node	file:
parent	BST.cpp	/^		node* parent;$/;"	m	class:BST::node	file:
parent	BST_MAP.hpp	/^	node* parent;$/;"	m	class:node
parent	BST_MAP_NOCOMPARE.hpp	/^	node* parent;$/;"	m	class:node
parent	BST_old.hpp	/^	node_t* parent;$/;"	m	class:BST
parent	BST_old.hpp	/^	node_t* parent;$/;"	m	class:node
pointer	map.hpp	/^			typedef typename Allocator::pointer			pointer;$/;"	t	class:ft::map
pointer	random_access_iterator.hpp	/^	typedef T*						pointer;$/;"	t	class:ft::random_access_iterator
pointer	random_access_iterator_rev.hpp	/^	typedef T*							pointer;$/;"	t	class:ft::random_access_iterator_rev
pointer	vector.hpp	/^    typedef typename allocator_type::pointer 					pointer;$/;"	t	class:ft::vector
pop	stack.hpp	/^	void pop(void) { c.pop_back(); }$/;"	f	class:ft::stack
pop_back	vector.hpp	/^	void	pop_back()$/;"	f	class:ft::vector
pos	BST_iterator.bak.hpp	/^	ptr		pos;$/;"	m	class:ft::BST_iterator
pos	BST_iterator.orig.hpp	/^	ptr		pos;$/;"	m	class:ft::BST_iterator
pos	vector.hpp	/^		size_type		pos;$/;"	m	class:ft::vector
prev	main.cpp	/^    Trunk *prev;$/;"	m	struct:Trunk	file:
prev	tree.cpp	/^    Trunk *prev;$/;"	m	struct:Trunk	file:
printPair	main.cpp	/^std::string	printPair(const T &iterator, bool nl = true, std::ostream &o = std::cout)$/;"	f
printPair	main_erase.cpp	/^std::string	printPair(const T &iterator, bool nl = true, std::ostream &o = std::cout)$/;"	f
printPair	mainite.cpp	/^std::string	printPair(const T &iterator, bool nl = true, std::ostream &o = std::cout)$/;"	f
printSize	main.cpp	/^void	printSize(T_MAP const &mp, bool print_content = 1)$/;"	f
printSize	main_erase.cpp	/^void	printSize(T_MAP const &mp, bool print_content = 1)$/;"	f
printSize	mainite.cpp	/^void	printSize(T_MAP const &mp, bool print_content = 1)$/;"	f
printTree	main.cpp	/^void printTree(node<$KEY, $T>* root, Trunk *prev, bool isLeft)$/;"	f
printTree	tree.cpp	/^void printTree($NODE_TYPE* root, Trunk *prev, bool isLeft)$/;"	f
ptr	BST_iterator.bak.hpp	/^	typedef BST_NODE* ptr;$/;"	t	class:ft::BST_iterator
ptr	BST_iterator.hpp	/^	typedef BST_NODE* ptr;$/;"	t	class:ft::BST_iterator
ptr	BST_iterator.orig.hpp	/^	typedef BST_NODE* ptr;$/;"	t	class:ft::BST_iterator
ptr	BST_iterator_rev.hpp	/^	typedef BST_NODE* ptr;$/;"	t	class:ft::BST_iterator_rev
ptr	random_access_iterator.hpp	/^		pointer ptr;$/;"	m	class:ft::random_access_iterator
ptr	random_access_iterator_rev.hpp	/^		pointer ptr;$/;"	m	class:ft::random_access_iterator_rev
push	stack.hpp	/^	void push (const value_type& val) { c.push_back(val); }$/;"	f	class:ft::stack
push_back	vector.hpp	/^	void	push_back(const value_type& val)$/;"	f	class:ft::vector
random_access_iterator	random_access_iterator.hpp	/^	random_access_iterator(const random_access_iterator& src) : ptr(src.getElemPtr()) {}$/;"	f	class:ft::random_access_iterator
random_access_iterator	random_access_iterator.hpp	/^	random_access_iterator(pointer init = 0) : ptr(init) {}  $/;"	f	class:ft::random_access_iterator
random_access_iterator	random_access_iterator.hpp	/^class random_access_iterator$/;"	c	namespace:ft
random_access_iterator_rev	random_access_iterator_rev.hpp	/^	random_access_iterator_rev(const random_access_iterator<T>& src) : ptr(src.getElemPtr() - 1) {}$/;"	f	class:ft::random_access_iterator_rev
random_access_iterator_rev	random_access_iterator_rev.hpp	/^	random_access_iterator_rev(pointer init = 0) : ptr(init) {}  $/;"	f	class:ft::random_access_iterator_rev
random_access_iterator_rev	random_access_iterator_rev.hpp	/^class random_access_iterator_rev$/;"	c	namespace:ft
range	random_access_iterator.hpp	/^	typedef long int 				range;$/;"	t	class:ft::random_access_iterator
range	random_access_iterator_rev.hpp	/^	typedef long int 					range;$/;"	t	class:ft::random_access_iterator_rev
rbegin	BST_MAP.hpp	/^	const_reverse_iterator	rbegin() const { return(reverse_iterator(root, maxR(root), false)); }$/;"	f	class:BST
rbegin	BST_MAP.hpp	/^	reverse_iterator	rbegin() { return(reverse_iterator(root, maxR(root), false)); }$/;"	f	class:BST
rbegin	BST_MAP_NOCOMPARE.hpp	/^	const_reverse_iterator	rbegin() const { return(reverse_iterator(root, maxR(root), false)); }$/;"	f	class:BST
rbegin	BST_MAP_NOCOMPARE.hpp	/^	reverse_iterator	rbegin() { return(reverse_iterator(root, maxR(root), false)); }$/;"	f	class:BST
rbegin	map.hpp	/^			const_reverse_iterator	rbegin() const { return(tree.rbegin()); }$/;"	f	class:ft::map
rbegin	map.hpp	/^			reverse_iterator	rbegin() { return(tree.rbegin()); }$/;"	f	class:ft::map
rbegin	vector.hpp	/^	const_reverse_iterator rbegin() const { return (reverse_iterator(_array + pos - 1)); }$/;"	f	class:ft::vector
rbegin	vector.hpp	/^	reverse_iterator rbegin() { return (reverse_iterator(_array + pos - 1)); }$/;"	f	class:ft::vector
ref	BST_iterator.bak.hpp	/^	typedef BST_NODE& ref;$/;"	t	class:ft::BST_iterator
ref	BST_iterator.orig.hpp	/^	typedef BST_NODE& ref;$/;"	t	class:ft::BST_iterator
reference	map.hpp	/^			typedef typename Allocator::reference		reference;$/;"	t	class:ft::map
reference	random_access_iterator.hpp	/^	typedef T&						reference;$/;"	t	class:ft::random_access_iterator
reference	random_access_iterator_rev.hpp	/^	typedef T&							reference;$/;"	t	class:ft::random_access_iterator_rev
reference	vector.hpp	/^    typedef typename allocator_type::reference 					reference;$/;"	t	class:ft::vector
rend	BST_MAP.hpp	/^	const_reverse_iterator	rend() const { return(reverse_iterator(root, NULL, true)); }$/;"	f	class:BST
rend	BST_MAP.hpp	/^	reverse_iterator	rend() { return(reverse_iterator(root, NULL, true)); }$/;"	f	class:BST
rend	BST_MAP_NOCOMPARE.hpp	/^	const_reverse_iterator	rend() const { return(reverse_iterator(root, maxL(root), false)); }$/;"	f	class:BST
rend	BST_MAP_NOCOMPARE.hpp	/^	reverse_iterator	rend() { return(reverse_iterator(root, maxL(root), false)); }$/;"	f	class:BST
rend	map.hpp	/^			const_reverse_iterator	rend() const { return(tree.rend()); }$/;"	f	class:ft::map
rend	map.hpp	/^			reverse_iterator	rend() { return(tree.rend()); }$/;"	f	class:ft::map
rend	vector.hpp	/^	reverse_iterator rend() { return (reverse_iterator(_array - 1)); }$/;"	f	class:ft::vector
reserve	vector.hpp	/^	void		reserve(size_type n)$/;"	f	class:ft::vector
resize	vector.hpp	/^	void		resize(size_type n, value_type val = value_type())$/;"	f	class:ft::vector
result_type	map.hpp	/^    typedef Result result_type;$/;"	t	struct:ft::binary_function
reverse_iterator	BST_MAP.hpp	/^	typedef ft::BST_iterator_rev<value_type, node> reverse_iterator;$/;"	t	class:BST
reverse_iterator	BST_MAP_NOCOMPARE.hpp	/^	typedef ft::BST_iterator<value_type, node> reverse_iterator;$/;"	t	class:BST
reverse_iterator	map.hpp	/^			typedef ft::BST_iterator_rev<value_type, node_t> reverse_iterator;$/;"	t	class:ft::map
reverse_iterator	vector.hpp	/^	typedef typename ft::random_access_iterator_rev<T>			reverse_iterator;$/;"	t	class:ft::vector
right	BST.cpp	/^		node* right;$/;"	m	class:BST::node	file:
right	BST_MAP.hpp	/^	node* right;$/;"	m	class:node
right	BST_MAP_NOCOMPARE.hpp	/^	node* right;$/;"	m	class:node
right	BST_old.hpp	/^	node_t* right;$/;"	m	class:node
rightRotate	BST_MAP.hpp	/^	node* rightRotate(node *x)$/;"	f	class:BST
rightRotate	BST_MAP_NOCOMPARE.hpp	/^	node* rightRotate(node *x)$/;"	f	class:BST
rm	BST_MAP.hpp	/^	bool	rm(value_type $pair)$/;"	f	class:BST
rm	BST_MAP_NOCOMPARE.hpp	/^	bool	rm(value_type $pair)$/;"	f	class:BST
rm	BST_old.hpp	/^	bool	rm(T1 value)$/;"	f	class:BST
root	BST.cpp	/^		node* root;$/;"	m	class:BST	file:
root	BST_MAP.hpp	/^	node* root;$/;"	m	class:BST
root	BST_MAP_NOCOMPARE.hpp	/^		node* root;$/;"	m	class:BST
root	BST_iterator.bak.hpp	/^	ptr		root;$/;"	m	class:ft::BST_iterator
root	BST_iterator.hpp	/^		ptr root;$/;"	m	class:ft::BST_iterator
root	BST_iterator.orig.hpp	/^	ptr		root;$/;"	m	class:ft::BST_iterator
root	BST_iterator_rev.hpp	/^		ptr root;$/;"	m	class:ft::BST_iterator_rev
search	BST_MAP.hpp	/^	node* search(value_type $pair) const$/;"	f	class:BST
search	BST_MAP_NOCOMPARE.hpp	/^	node* search(value_type $pair)$/;"	f	class:BST
search	BST_old.hpp	/^	node_t* search(T1 value)$/;"	f	class:BST
second	ft_pair.hpp	/^    second_type second;$/;"	m	struct:ft::pair
second_argument_type	map.hpp	/^    typedef Arg2 second_argument_type;$/;"	t	struct:ft::binary_function
second_type	ft_pair.hpp	/^    typedef T2 second_type;$/;"	t	struct:ft::pair
setParent	BST.cpp	/^		void	setParent(node* $parent) { parent = $parent; }$/;"	f	class:BST::node
setParent	BST_MAP.hpp	/^	void	setParent(node* $parent) { parent = $parent; }$/;"	f	class:node
setParent	BST_MAP_NOCOMPARE.hpp	/^	void	setParent(node* $parent) { parent = $parent; }$/;"	f	class:node
setParent	BST_old.hpp	/^	void	setParent(node_t* $parent) { parent = $parent; }$/;"	f	class:node
setRoot	BST_MAP.hpp	/^	void	setRoot(node* $root) { root = $root; }$/;"	f	class:BST
setSize	BST_MAP.hpp	/^	void	setSize(size_t $size) { _size = $size; }$/;"	f	class:BST
setValue	BST_old.hpp	/^	void	setValue(T1 $value) { value = $value; }$/;"	f	class:node
showTrunks	main.cpp	/^void showTrunks(Trunk *p)$/;"	f
showTrunks	tree.cpp	/^void showTrunks(Trunk *p)$/;"	f
size	BST.cpp	/^		size_t size;$/;"	m	class:BST	file:
size	BST_old.hpp	/^	size_t size;$/;"	m	class:BST
size	map.hpp	/^			size_type	size() const { return(tree.getSize()); }$/;"	f	class:ft::map
size	stack.hpp	/^	size_type size(void) const { return c.size(); }$/;"	f	class:ft::stack
size	vector.hpp	/^	size_type size() const			{ return (pos); } \/\/ return current container size$/;"	f	class:ft::vector
size_type	map.hpp	/^			typedef	size_t								size_type;$/;"	t	class:ft::map
size_type	stack.hpp	/^	typedef size_t			size_type;$/;"	t	class:ft::stack
size_type	vector.hpp	/^    typedef size_t												size_type;$/;"	t	class:ft::vector
stack	stack.hpp	/^	explicit stack(const container_type& ctnr = container_type()) : c(ctnr) {}$/;"	f	class:ft::stack
stack	stack.hpp	/^class stack {$/;"	c	namespace:ft
stoi	tree.cpp	/^int		stoi(str elem)$/;"	f	namespace:ft
str	main.cpp	/^    std::string str;$/;"	m	struct:Trunk	file:
str	tree.cpp	/^    std::string str;$/;"	m	struct:Trunk	file:
str	tree.cpp	/^typedef std::string str;$/;"	t	file:
sub	random_access_iterator.hpp	/^	#define sub(/;"	d
sub2	random_access_iterator_rev.hpp	/^	#define sub2(/;"	d
swap	map.hpp	/^			void	swap(map<Key, T, Compare, Allocator>& x)$/;"	f	class:ft::map
swap	map.hpp	/^			void swap(map<Key,T,Compare,Allocator>& x,$/;"	f	namespace:ft
swap	vector.hpp	/^	friend void swap(vector<T, Alloc>& left, vector<T, Alloc>& right) { left.swap(right); }$/;"	f	class:ft::vector
swap	vector.hpp	/^	void	swap(vector& x)$/;"	f	class:ft::vector
this_class	random_access_iterator.hpp	/^	typedef random_access_iterator	this_class;$/;"	t	class:ft::random_access_iterator
this_class	random_access_iterator_rev.hpp	/^	typedef random_access_iterator_rev	this_class;$/;"	t	class:ft::random_access_iterator_rev
top	stack.hpp	/^	const value_type& top(void) const { return c.back(); }$/;"	f	class:ft::stack
top	stack.hpp	/^	value_type& top(void) { return c.back(); }$/;"	f	class:ft::stack
tree	map.hpp	/^				BST<Key, T, value_compare>  tree;$/;"	m	class:ft::map
type	enable_if.hpp	/^    struct enable_if<true> { typedef int type; };$/;"	t	struct:enable_if
updateHeight	BST_MAP.hpp	/^	void	updateHeight(node *start)$/;"	f	class:BST
updateHeight	BST_MAP_NOCOMPARE.hpp	/^	void	updateHeight(node *start)$/;"	f	class:BST
updateHeight2	BST_MAP.hpp	/^	void	updateHeight2(node *x)$/;"	f	class:BST
upper_bound	BST_MAP.hpp	/^	node*	upper_bound(const Key& x) const$/;"	f	class:BST
upper_bound	map.hpp	/^			const_iterator	upper_bound(const key_type& x) const$/;"	f	class:ft::map
upper_bound	map.hpp	/^			iterator	upper_bound(const key_type& x)$/;"	f	class:ft::map
val	BST_iterator.hpp	/^		ft::pair<BST_NODE*, bool> val;$/;"	m	class:ft::BST_iterator
val	BST_iterator_rev.hpp	/^		ft::pair<BST_NODE*, bool> val;$/;"	m	class:ft::BST_iterator_rev
val_nil	BST_iterator.hpp	/^	#define val_nil /;"	d
val_nil	BST_iterator_rev.hpp	/^	#define val_nil /;"	d
val_ptr	BST_iterator.hpp	/^	#define val_ptr /;"	d
val_ptr	BST_iterator_rev.hpp	/^	#define val_ptr /;"	d
value	BST_old.hpp	/^	T1 value;$/;"	m	class:node
value	enable_if.hpp	/^    struct is_integral { static const bool value = false; };$/;"	m	struct:is_integral
value	enable_if.hpp	/^    struct is_integral<bool> { static const bool value = true; };$/;"	m	struct:is_integral
value	enable_if.hpp	/^    struct is_integral<char> { static const bool value = true; };$/;"	m	struct:is_integral
value	enable_if.hpp	/^    struct is_integral<int> { static const bool value = true; };$/;"	m	struct:is_integral
value	enable_if.hpp	/^    struct is_integral<long long> { static const bool value = true; };$/;"	m	struct:is_integral
value	enable_if.hpp	/^    struct is_integral<long> { static const bool value = true; };$/;"	m	struct:is_integral
value	enable_if.hpp	/^    struct is_integral<short> { static const bool value = true; };$/;"	m	struct:is_integral
value	enable_if.hpp	/^    struct is_integral<unsigned char> { static const bool value = true; };$/;"	m	struct:is_integral
value	enable_if.hpp	/^    struct is_integral<unsigned int> { static const bool value = true; };$/;"	m	struct:is_integral
value	enable_if.hpp	/^    struct is_integral<unsigned long long> { static const bool value = true; };$/;"	m	struct:is_integral
value	enable_if.hpp	/^    struct is_integral<unsigned long> { static const bool value = true; };$/;"	m	struct:is_integral
value	enable_if.hpp	/^    struct is_integral<unsigned short> { static const bool value = true; };$/;"	m	struct:is_integral
value_comp	map.hpp	/^			value_compare	value_comp() const { return(key_comp()); }$/;"	f	class:ft::map
value_compare	map.hpp	/^				value_compare(Compare c) : comp(c) {}$/;"	f	class:ft::map::value_compare
value_compare	map.hpp	/^			class value_compare : public binary_function<value_type, value_type, bool>$/;"	c	class:ft::map
value_type	BST_MAP.hpp	/^	typedef ft::pair<const Key, T>					value_type;$/;"	t	class:BST
value_type	BST_MAP.hpp	/^	typedef ft::pair<const Key, T>					value_type;$/;"	t	class:node
value_type	BST_MAP_NOCOMPARE.hpp	/^	typedef ft::pair<const Key, T>					value_type;$/;"	t	class:BST
value_type	BST_MAP_NOCOMPARE.hpp	/^	typedef ft::pair<const Key, T>					value_type;$/;"	t	class:node
value_type	BST_iterator.bak.hpp	/^	typedef T value_type;$/;"	t	class:ft::BST_iterator
value_type	BST_iterator.orig.hpp	/^	typedef T value_type;$/;"	t	class:ft::BST_iterator
value_type	map.hpp	/^			typedef pair<const Key, T>					value_type;$/;"	t	class:ft::map
value_type	stack.hpp	/^	typedef T				value_type;$/;"	t	class:ft::stack
value_type	vector.hpp	/^	typedef T 													value_type;$/;"	t	class:ft::vector
vector	vector.hpp	/^		vector (InputIterator first, InputIterator last,$/;"	f	class:ft::vector
vector	vector.hpp	/^	explicit vector (const allocator_type& alloc = allocator_type()) : pos(0), _capacity(0), _array($mem_get(0)) {(void)alloc;}$/;"	f	class:ft::vector
vector	vector.hpp	/^	explicit vector (size_type n, const value_type& val = value_type(),$/;"	f	class:ft::vector
vector	vector.hpp	/^	vector(const vector &x) :pos(x.pos), _Base(x._Base), _capacity(x._capacity)$/;"	f	class:ft::vector
vector	vector.hpp	/^template <typename T, class Alloc = std::allocator<T> > class vector$/;"	c	namespace:ft
~BST	BST.cpp	/^	~BST() {}$/;"	f	class:BST	file:
~BST	BST_MAP.hpp	/^	~BST() {}$/;"	f	class:BST
~BST	BST_MAP_NOCOMPARE.hpp	/^	~BST() {}$/;"	f	class:BST
~BST	BST_old.hpp	/^	~BST() {}$/;"	f	class:BST
~BST_iterator	BST_iterator.bak.hpp	/^	~BST_iterator() {}$/;"	f	class:ft::BST_iterator
~BST_iterator	BST_iterator.hpp	/^	 ~BST_iterator() {}$/;"	f	class:ft::BST_iterator
~BST_iterator	BST_iterator.orig.hpp	/^	~BST_iterator() {}$/;"	f	class:ft::BST_iterator
~BST_iterator_rev	BST_iterator_rev.hpp	/^	 ~BST_iterator_rev() {}$/;"	f	class:ft::BST_iterator_rev
~map	map.hpp	/^			~map() {}$/;"	f	class:ft::map
~node	BST.cpp	/^		~node() {}$/;"	f	class:BST::node
~node	BST_MAP.hpp	/^	~node() {}$/;"	f	class:node
~node	BST_MAP_NOCOMPARE.hpp	/^	~node() {}$/;"	f	class:node
~node	BST_old.hpp	/^	~node() {}$/;"	f	class:node
~random_access_iterator	random_access_iterator.hpp	/^	~random_access_iterator() {}$/;"	f	class:ft::random_access_iterator
~random_access_iterator_rev	random_access_iterator_rev.hpp	/^	~random_access_iterator_rev() {}     $/;"	f	class:ft::random_access_iterator_rev
~stack	stack.hpp	/^	~stack(void) {}$/;"	f	class:ft::stack
~vector	vector.hpp	/^	~vector() { $clear_erase; }$/;"	f	class:ft::vector
